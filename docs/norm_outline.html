<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>norm_outline API documentation</title>
<meta name="description" content="Process and shape image boundary data vectors. Misc routines to
shape / normalize / sort compare arrays.
The initial attempt was to convert them by â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>norm_outline</code></h1>
</header>
<section id="section-intro">
<p>Process and shape image boundary data vectors. Misc routines to
shape / normalize / sort compare arrays.
The initial attempt was to convert them by sorting on rotational vector.
However, the simple sort is just fine.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python

import math
import pyimgutils as iut

__doc__ = &#39;&#39;&#39;

  Process and shape image boundary data vectors. Misc routines to
  shape / normalize / sort compare arrays.
  The initial attempt was to convert them by sorting on rotational vector.
  However, the simple sort is just fine.

&#39;&#39;&#39;

#: This is the sample size that is stored in the shape array
ARRLEN = 100

def norm_array(fparm):

    &#39;&#39;&#39;
        Process the array for vector rotation. Return normalized coordinate array.
        This is superseeded by simple sorting, with similar results.
    &#39;&#39;&#39;

    resarr = [];

    # Correct order
    minx2 = min(fparm.minx, fparm.maxx);  miny2 = min(fparm.miny, fparm.maxy)
    maxx2 = max(fparm.minx, fparm.maxx);  maxy2 = max(fparm.miny, fparm.maxy)
    #print( &#34;minx2&#34;, minx2, &#34;maxx2&#34;, maxx2, &#34;miny2&#34;, miny2, &#34;maxy2&#34;, maxy2)
    maxwx = maxx2 - minx2; maxhy = maxy2 - miny2

    midx = maxwx // 2; midy = maxhy // 2;
    #print( &#34;midx&#34;, midx, &#34;midy&#34;, midy       )

    # Normalize to zero based for the small image, clean non zeros
    xarr = flush_upleft(fparm)

    #xsarr = sorted(xarr.keys())
    #xsarr = xarr.keys();

    # Quadrants. Visualizer tells us to parse in clock winding order.
    # Starting from upper left ...
    #     xx  yy      |-----|-----|
    #     -1, -1      |  1  |  2  |
    #     +1, -1      |-----|-----|
    #     +1, +1      |  4  |  3  |
    #     -1, +1      |-----|-----|

    carr1 = {}; carr2 = {};  carr3 = {};  carr4 = {}
    for bb in xarr:
        # Normalize it to the center
        # minx  ----  midx ----  maxx
        if bb[0] &gt; midx: xx = bb[0] - midx;
        else: xx = - (midx - bb[0])
        if bb[1] &gt; midy: yy = bb[1] - midy;
        else: yy = - (midy - bb[1])
        #print(&#34;xx&#34;, xx, &#34;yy&#34;, yy)

        # Distribute quadrants
        if (xx &lt;= 0) and (yy &lt;= 0):   carr1[xx, yy] = 1
        elif (xx &gt; 0) and (yy &lt;= 0):  carr2[xx, yy] = 1
        elif (xx &gt; 0) and (yy &gt; 0):   carr3[xx, yy] = 1
        elif (xx &lt;= 0) and (yy &gt; 0):  carr4[xx, yy] = 1
        #else: print( &#34;Bad juju&#34;)
        #print(&#34;carr1&#34;, carr1)

    # Sort them by angle
    resarr += order_vectors(carr1, midx, midy)
    resarr += order_vectors(carr2, midx, midy)
    resarr += order_vectors(carr3, midx, midy)
    resarr += order_vectors(carr4, midx, midy)
    #print( &#34;shape arr len&#34;, len(resarr))
    #return resarr

    # Shape them uniform, number of elements, maximum magnitude
    resarr2 = scale_vectors(resarr, ARRLEN)
    #return resarr2
    resarr3 = scale_magnitude(resarr2, ARRLEN)
    return resarr3

def norm_vectors(vects, minx, miny, size = ARRLEN):

    &#39;&#39;&#39; Call subsequent norm / scale routines &#39;&#39;&#39;

    ulf = flush_upleft(vects, minx, miny)
    nbs = scale_vectors(ulf, size)
    nbm = scale_magnitude(nbs, size)
    return nbm

def flush_upleft(vects, minx = 0, miny = 0):

    &#39;&#39;&#39; Make sure vector origin at 0,0 (minx, miny)

    Parameters
    ----------

        vects           vectors to operate on
        minx, miny      flush reference point

    &#39;&#39;&#39;

    xarr = []
    for aa in vects:
        xarr.append(([aa[0] - minx, aa[1] - miny]))
    return xarr

def order_vectors(carr, midx, midy, rev = False):

    &#39;&#39;&#39; Order vectors. Calculate vector tangent and sort by it.
        Obsolete. Kept because it may be useful in the future.
    &#39;&#39;&#39;

    vec = []; resarr = []
    for cc in carr.keys():
        if cc[0]:                           # prevent divide by zero
            vvv = float(cc[1]) / cc[0]
            vec.append((vvv, cc))
    vec.sort()
    for dd in vec:
        resarr.append((dd[1][0] + midx, dd[1][1] + midy))
    return resarr

def scale_vectors(carr, newsize):

    &#39;&#39;&#39; Scale array to preset lenth. Discards the rest, or duplicates
    dependent on the array size and parameter newsize
    &#39;&#39;&#39;

    resarr = []; arrlen = len(carr)
    step = float(arrlen) / newsize
    for aa in range(newsize):
        try:
            resarr.append(carr[int(aa * step)] )
        except:
            print(&#34;exc scale&#34;, aa, arrlen) #, sys.exc_info())
    return resarr

def scale_magnitude(carr, newval):

    &#39;&#39;&#39; Scale array to preset value range. Note that the value has
        to be index ARRLEN, which is one less than ARRLEN.
    &#39;&#39;&#39;

    resarr = [];  maxval = 0;
    # Calculate maximum value
    for aa in carr:
        maxval = max(maxval, aa[0]);
        maxval = max(maxval, aa[1])

    rat = float(maxval) / (newval - 1)
    #print( &#34;maxval&#34;, maxval, &#34;rat&#34;, rat, &#34;len&#34;, len(carr))

    # Scale it
    for aa in range(len(carr)):
        xx = float(carr[aa][0]) / rat;  yy = float(carr[aa][1]) / rat
        resarr.append( (int(math.floor(xx)), int(math.floor(yy))) )
    #print(&#34;resarr&#34;, resarr)
    return resarr

def cmp_arrays(arr1, arr2, span = 3):

    &#39;&#39;&#39; Compare two arrays, look sideways for closer match

        Parameters:  &lt;br&gt;

            arr1, arr2      arrays to compare
            span            how musch to look sideways
    &#39;&#39;&#39;

    xlen = min(len(arr1), len(arr2))
    if xlen &lt; span + 2:
        print(&#34;Array not long enough&#34;)
        return

    ret = 0;
    for aa in range(span, xlen - (span+1)):
        ref = arr1[aa][0]; ref2 = arr1[aa][1]
        inter = 0xffff
        for bb in range(-span, span+1):
            xx1 = abs(ref - arr2[aa+bb][0])
            yy1 = abs(ref2 - arr2[aa+bb][1])
            #dd = math.sqrt(xx1 * xx1 + yy1 * yy1)
            dd = abs(xx1 + yy1)
            #print(&#34;eval %d %.2f &#34; % (bb, dd), xx1, yy1)
            inter = min(dd, inter)
        ret += inter
    return int(ret)

def cmp_arrays2(arr1, arr2):

    &#39;&#39;&#39; Compare two arrays, old version (never mind) &#39;&#39;&#39;

    ret = 0; xlen = min(len(arr1), len(arr2))
    for aa in range(1, xlen - 1):

        dd1 = arr1[aa][0] - arr2[aa-1][0]
        dd2 = arr1[aa][1] - arr2[aa-1][1]
        dd = math.sqrt(dd1 * dd1 + dd2 * dd2)

        ddd1 = arr1[aa][0] - arr2[aa][0]
        ddd2 = arr1[aa][1] - arr2[aa][1]
        ddd = math.sqrt(ddd1 * ddd1 + ddd2 * ddd2)

        dddd1 = arr1[aa+1][0] - arr2[aa+1][0]
        dddd2 = arr1[aa+1][1] - arr2[aa+1][1]
        dddd = math.sqrt(dddd1 * dddd1 + dddd2 * dddd2)

        inter = min(dd, ddd)
        ret += min(inter, dddd)

    return ret

def norm_array2(fparm):

    &#39;&#39;&#39; Process the array for vector proximity (old)
    &#39;&#39;&#39;

    resarr = [];

    minx = fparm.minx;  miny = fparm.miny
    maxx = fparm.maxx - fparm.minx;
    maxy = fparm.maxy - fparm.miny

    #print( fparm.bounds)

    # Normalize to zero based for the small image, clean non zeros
    xarr = {}
    for aa in fparm.bounds.keys():
        if fparm.bounds[aa]:
            xarr[aa[0] - minx, aa[1] - miny] = 1
    #print( xarr    )

    # This will yield top left point as element 0
    xsarr = sorted(xarr.keys())
    #print( xsarr)
    #return xsarr

    # Assure winding. Look for closest right, then up, then down, then left
    progarr = []; prog = 0
    while True:
        if len(progarr) &gt;= len(xsarr) - 1: break      # End cycle
        progarr.append(prog)                          # Mark point done
        curr =  xsarr[prog]; warr = []
        #print( &#34;curr&#34;, curr, &#34;prog&#34;, prog, &#34;wlen&#34;, len(xsarr), )

        for cc in range(0, len(xsarr)):
            if cc == prog:                          # Self
                continue
            if cc in progarr:                       # Visited
                continue
            dist = sqrdiff(xsarr[cc][0] - curr[0], xsarr[cc][1] - curr[1])
            if dist !=  0:                  # Exclude self
                #print( xsarr[cc], &#34;%.2d&#34; % dist, &#34;  &#34;,)
                warr.append((dist, cc))

        if len(warr) &gt; 1:                      # The end pos has no connection
            warr.sort(key=lambda val: val[0])  # Get the smallest distance
            #warr.sort()
            #print( &#34;warr&#34;, warr)
            collision = warr[0][0] == warr[1][0]
            # After long delibaration, the simplest way to handle this is
            # to ignore collisions
            if collision:
                print( &#34;warr collision&#34;, warr[0], warr[1])
                for dd in range(len(warr) - 1):
                    print( warr[dd], xsarr[warr[dd][1]] )
                    if warr[dd][0] != warr[dd+1][0]:
                        break
            else:
                resarr.append((xsarr[prog][0], xsarr[prog][1]))
                # Now go to the last found, repeat
            prog =  warr[0][1]
        #print()
    return resarr

def sqrdiff(aa, bb):

    &#39;&#39;&#39; Math sugar for absolute difference. Not used, as it is too expensive. &#39;&#39;&#39;

    dist = math.sqrt(abs(math.pow(bb, 2) - \
                math.pow(aa, 2)))
    return dist

def norm_bounds(boundx, bounds):

    &#39;&#39;&#39; Make it upper left aligned &#39;&#39;&#39;

    print(&#34;norm_bounds() boundx = &#34;, boundx)
    retdict = {}
    for aa in bounds.keys():
        if bounds[aa]:
            iut.mark_cell(aa[0] - boundx[0], aa[1] - boundx[1],  1, retdict)
    return retdict

# EOF</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="norm_outline.ARRLEN"><code class="name">var <span class="ident">ARRLEN</span></code></dt>
<dd>
<div class="desc"><p>This is the sample size that is stored in the shape array</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="norm_outline.cmp_arrays"><code class="name flex">
<span>def <span class="ident">cmp_arrays</span></span>(<span>arr1, arr2, span=3)</span>
</code></dt>
<dd>
<div class="desc"><p>Compare two arrays, look sideways for closer match</p>
<p>Parameters:
<br></p>
<pre><code>arr1, arr2      arrays to compare
span            how musch to look sideways
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cmp_arrays(arr1, arr2, span = 3):

    &#39;&#39;&#39; Compare two arrays, look sideways for closer match

        Parameters:  &lt;br&gt;

            arr1, arr2      arrays to compare
            span            how musch to look sideways
    &#39;&#39;&#39;

    xlen = min(len(arr1), len(arr2))
    if xlen &lt; span + 2:
        print(&#34;Array not long enough&#34;)
        return

    ret = 0;
    for aa in range(span, xlen - (span+1)):
        ref = arr1[aa][0]; ref2 = arr1[aa][1]
        inter = 0xffff
        for bb in range(-span, span+1):
            xx1 = abs(ref - arr2[aa+bb][0])
            yy1 = abs(ref2 - arr2[aa+bb][1])
            #dd = math.sqrt(xx1 * xx1 + yy1 * yy1)
            dd = abs(xx1 + yy1)
            #print(&#34;eval %d %.2f &#34; % (bb, dd), xx1, yy1)
            inter = min(dd, inter)
        ret += inter
    return int(ret)</code></pre>
</details>
</dd>
<dt id="norm_outline.cmp_arrays2"><code class="name flex">
<span>def <span class="ident">cmp_arrays2</span></span>(<span>arr1, arr2)</span>
</code></dt>
<dd>
<div class="desc"><p>Compare two arrays, old version (never mind)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cmp_arrays2(arr1, arr2):

    &#39;&#39;&#39; Compare two arrays, old version (never mind) &#39;&#39;&#39;

    ret = 0; xlen = min(len(arr1), len(arr2))
    for aa in range(1, xlen - 1):

        dd1 = arr1[aa][0] - arr2[aa-1][0]
        dd2 = arr1[aa][1] - arr2[aa-1][1]
        dd = math.sqrt(dd1 * dd1 + dd2 * dd2)

        ddd1 = arr1[aa][0] - arr2[aa][0]
        ddd2 = arr1[aa][1] - arr2[aa][1]
        ddd = math.sqrt(ddd1 * ddd1 + ddd2 * ddd2)

        dddd1 = arr1[aa+1][0] - arr2[aa+1][0]
        dddd2 = arr1[aa+1][1] - arr2[aa+1][1]
        dddd = math.sqrt(dddd1 * dddd1 + dddd2 * dddd2)

        inter = min(dd, ddd)
        ret += min(inter, dddd)

    return ret</code></pre>
</details>
</dd>
<dt id="norm_outline.flush_upleft"><code class="name flex">
<span>def <span class="ident">flush_upleft</span></span>(<span>vects, minx=0, miny=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Make sure vector origin at 0,0 (minx, miny)</p>
<h2 id="parameters">Parameters</h2>
<pre><code>vects           vectors to operate on
minx, miny      flush reference point
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flush_upleft(vects, minx = 0, miny = 0):

    &#39;&#39;&#39; Make sure vector origin at 0,0 (minx, miny)

    Parameters
    ----------

        vects           vectors to operate on
        minx, miny      flush reference point

    &#39;&#39;&#39;

    xarr = []
    for aa in vects:
        xarr.append(([aa[0] - minx, aa[1] - miny]))
    return xarr</code></pre>
</details>
</dd>
<dt id="norm_outline.norm_array"><code class="name flex">
<span>def <span class="ident">norm_array</span></span>(<span>fparm)</span>
</code></dt>
<dd>
<div class="desc"><p>Process the array for vector rotation. Return normalized coordinate array.
This is superseeded by simple sorting, with similar results.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def norm_array(fparm):

    &#39;&#39;&#39;
        Process the array for vector rotation. Return normalized coordinate array.
        This is superseeded by simple sorting, with similar results.
    &#39;&#39;&#39;

    resarr = [];

    # Correct order
    minx2 = min(fparm.minx, fparm.maxx);  miny2 = min(fparm.miny, fparm.maxy)
    maxx2 = max(fparm.minx, fparm.maxx);  maxy2 = max(fparm.miny, fparm.maxy)
    #print( &#34;minx2&#34;, minx2, &#34;maxx2&#34;, maxx2, &#34;miny2&#34;, miny2, &#34;maxy2&#34;, maxy2)
    maxwx = maxx2 - minx2; maxhy = maxy2 - miny2

    midx = maxwx // 2; midy = maxhy // 2;
    #print( &#34;midx&#34;, midx, &#34;midy&#34;, midy       )

    # Normalize to zero based for the small image, clean non zeros
    xarr = flush_upleft(fparm)

    #xsarr = sorted(xarr.keys())
    #xsarr = xarr.keys();

    # Quadrants. Visualizer tells us to parse in clock winding order.
    # Starting from upper left ...
    #     xx  yy      |-----|-----|
    #     -1, -1      |  1  |  2  |
    #     +1, -1      |-----|-----|
    #     +1, +1      |  4  |  3  |
    #     -1, +1      |-----|-----|

    carr1 = {}; carr2 = {};  carr3 = {};  carr4 = {}
    for bb in xarr:
        # Normalize it to the center
        # minx  ----  midx ----  maxx
        if bb[0] &gt; midx: xx = bb[0] - midx;
        else: xx = - (midx - bb[0])
        if bb[1] &gt; midy: yy = bb[1] - midy;
        else: yy = - (midy - bb[1])
        #print(&#34;xx&#34;, xx, &#34;yy&#34;, yy)

        # Distribute quadrants
        if (xx &lt;= 0) and (yy &lt;= 0):   carr1[xx, yy] = 1
        elif (xx &gt; 0) and (yy &lt;= 0):  carr2[xx, yy] = 1
        elif (xx &gt; 0) and (yy &gt; 0):   carr3[xx, yy] = 1
        elif (xx &lt;= 0) and (yy &gt; 0):  carr4[xx, yy] = 1
        #else: print( &#34;Bad juju&#34;)
        #print(&#34;carr1&#34;, carr1)

    # Sort them by angle
    resarr += order_vectors(carr1, midx, midy)
    resarr += order_vectors(carr2, midx, midy)
    resarr += order_vectors(carr3, midx, midy)
    resarr += order_vectors(carr4, midx, midy)
    #print( &#34;shape arr len&#34;, len(resarr))
    #return resarr

    # Shape them uniform, number of elements, maximum magnitude
    resarr2 = scale_vectors(resarr, ARRLEN)
    #return resarr2
    resarr3 = scale_magnitude(resarr2, ARRLEN)
    return resarr3</code></pre>
</details>
</dd>
<dt id="norm_outline.norm_array2"><code class="name flex">
<span>def <span class="ident">norm_array2</span></span>(<span>fparm)</span>
</code></dt>
<dd>
<div class="desc"><p>Process the array for vector proximity (old)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def norm_array2(fparm):

    &#39;&#39;&#39; Process the array for vector proximity (old)
    &#39;&#39;&#39;

    resarr = [];

    minx = fparm.minx;  miny = fparm.miny
    maxx = fparm.maxx - fparm.minx;
    maxy = fparm.maxy - fparm.miny

    #print( fparm.bounds)

    # Normalize to zero based for the small image, clean non zeros
    xarr = {}
    for aa in fparm.bounds.keys():
        if fparm.bounds[aa]:
            xarr[aa[0] - minx, aa[1] - miny] = 1
    #print( xarr    )

    # This will yield top left point as element 0
    xsarr = sorted(xarr.keys())
    #print( xsarr)
    #return xsarr

    # Assure winding. Look for closest right, then up, then down, then left
    progarr = []; prog = 0
    while True:
        if len(progarr) &gt;= len(xsarr) - 1: break      # End cycle
        progarr.append(prog)                          # Mark point done
        curr =  xsarr[prog]; warr = []
        #print( &#34;curr&#34;, curr, &#34;prog&#34;, prog, &#34;wlen&#34;, len(xsarr), )

        for cc in range(0, len(xsarr)):
            if cc == prog:                          # Self
                continue
            if cc in progarr:                       # Visited
                continue
            dist = sqrdiff(xsarr[cc][0] - curr[0], xsarr[cc][1] - curr[1])
            if dist !=  0:                  # Exclude self
                #print( xsarr[cc], &#34;%.2d&#34; % dist, &#34;  &#34;,)
                warr.append((dist, cc))

        if len(warr) &gt; 1:                      # The end pos has no connection
            warr.sort(key=lambda val: val[0])  # Get the smallest distance
            #warr.sort()
            #print( &#34;warr&#34;, warr)
            collision = warr[0][0] == warr[1][0]
            # After long delibaration, the simplest way to handle this is
            # to ignore collisions
            if collision:
                print( &#34;warr collision&#34;, warr[0], warr[1])
                for dd in range(len(warr) - 1):
                    print( warr[dd], xsarr[warr[dd][1]] )
                    if warr[dd][0] != warr[dd+1][0]:
                        break
            else:
                resarr.append((xsarr[prog][0], xsarr[prog][1]))
                # Now go to the last found, repeat
            prog =  warr[0][1]
        #print()
    return resarr</code></pre>
</details>
</dd>
<dt id="norm_outline.norm_bounds"><code class="name flex">
<span>def <span class="ident">norm_bounds</span></span>(<span>boundx, bounds)</span>
</code></dt>
<dd>
<div class="desc"><p>Make it upper left aligned</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def norm_bounds(boundx, bounds):

    &#39;&#39;&#39; Make it upper left aligned &#39;&#39;&#39;

    print(&#34;norm_bounds() boundx = &#34;, boundx)
    retdict = {}
    for aa in bounds.keys():
        if bounds[aa]:
            iut.mark_cell(aa[0] - boundx[0], aa[1] - boundx[1],  1, retdict)
    return retdict</code></pre>
</details>
</dd>
<dt id="norm_outline.norm_vectors"><code class="name flex">
<span>def <span class="ident">norm_vectors</span></span>(<span>vects, minx, miny, size=100)</span>
</code></dt>
<dd>
<div class="desc"><p>Call subsequent norm / scale routines</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def norm_vectors(vects, minx, miny, size = ARRLEN):

    &#39;&#39;&#39; Call subsequent norm / scale routines &#39;&#39;&#39;

    ulf = flush_upleft(vects, minx, miny)
    nbs = scale_vectors(ulf, size)
    nbm = scale_magnitude(nbs, size)
    return nbm</code></pre>
</details>
</dd>
<dt id="norm_outline.order_vectors"><code class="name flex">
<span>def <span class="ident">order_vectors</span></span>(<span>carr, midx, midy, rev=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Order vectors. Calculate vector tangent and sort by it.
Obsolete. Kept because it may be useful in the future.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def order_vectors(carr, midx, midy, rev = False):

    &#39;&#39;&#39; Order vectors. Calculate vector tangent and sort by it.
        Obsolete. Kept because it may be useful in the future.
    &#39;&#39;&#39;

    vec = []; resarr = []
    for cc in carr.keys():
        if cc[0]:                           # prevent divide by zero
            vvv = float(cc[1]) / cc[0]
            vec.append((vvv, cc))
    vec.sort()
    for dd in vec:
        resarr.append((dd[1][0] + midx, dd[1][1] + midy))
    return resarr</code></pre>
</details>
</dd>
<dt id="norm_outline.scale_magnitude"><code class="name flex">
<span>def <span class="ident">scale_magnitude</span></span>(<span>carr, newval)</span>
</code></dt>
<dd>
<div class="desc"><p>Scale array to preset value range. Note that the value has
to be index ARRLEN, which is one less than ARRLEN.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scale_magnitude(carr, newval):

    &#39;&#39;&#39; Scale array to preset value range. Note that the value has
        to be index ARRLEN, which is one less than ARRLEN.
    &#39;&#39;&#39;

    resarr = [];  maxval = 0;
    # Calculate maximum value
    for aa in carr:
        maxval = max(maxval, aa[0]);
        maxval = max(maxval, aa[1])

    rat = float(maxval) / (newval - 1)
    #print( &#34;maxval&#34;, maxval, &#34;rat&#34;, rat, &#34;len&#34;, len(carr))

    # Scale it
    for aa in range(len(carr)):
        xx = float(carr[aa][0]) / rat;  yy = float(carr[aa][1]) / rat
        resarr.append( (int(math.floor(xx)), int(math.floor(yy))) )
    #print(&#34;resarr&#34;, resarr)
    return resarr</code></pre>
</details>
</dd>
<dt id="norm_outline.scale_vectors"><code class="name flex">
<span>def <span class="ident">scale_vectors</span></span>(<span>carr, newsize)</span>
</code></dt>
<dd>
<div class="desc"><p>Scale array to preset lenth. Discards the rest, or duplicates
dependent on the array size and parameter newsize</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scale_vectors(carr, newsize):

    &#39;&#39;&#39; Scale array to preset lenth. Discards the rest, or duplicates
    dependent on the array size and parameter newsize
    &#39;&#39;&#39;

    resarr = []; arrlen = len(carr)
    step = float(arrlen) / newsize
    for aa in range(newsize):
        try:
            resarr.append(carr[int(aa * step)] )
        except:
            print(&#34;exc scale&#34;, aa, arrlen) #, sys.exc_info())
    return resarr</code></pre>
</details>
</dd>
<dt id="norm_outline.sqrdiff"><code class="name flex">
<span>def <span class="ident">sqrdiff</span></span>(<span>aa, bb)</span>
</code></dt>
<dd>
<div class="desc"><p>Math sugar for absolute difference. Not used, as it is too expensive.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sqrdiff(aa, bb):

    &#39;&#39;&#39; Math sugar for absolute difference. Not used, as it is too expensive. &#39;&#39;&#39;

    dist = math.sqrt(abs(math.pow(bb, 2) - \
                math.pow(aa, 2)))
    return dist</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="norm_outline.ARRLEN" href="#norm_outline.ARRLEN">ARRLEN</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="norm_outline.cmp_arrays" href="#norm_outline.cmp_arrays">cmp_arrays</a></code></li>
<li><code><a title="norm_outline.cmp_arrays2" href="#norm_outline.cmp_arrays2">cmp_arrays2</a></code></li>
<li><code><a title="norm_outline.flush_upleft" href="#norm_outline.flush_upleft">flush_upleft</a></code></li>
<li><code><a title="norm_outline.norm_array" href="#norm_outline.norm_array">norm_array</a></code></li>
<li><code><a title="norm_outline.norm_array2" href="#norm_outline.norm_array2">norm_array2</a></code></li>
<li><code><a title="norm_outline.norm_bounds" href="#norm_outline.norm_bounds">norm_bounds</a></code></li>
<li><code><a title="norm_outline.norm_vectors" href="#norm_outline.norm_vectors">norm_vectors</a></code></li>
<li><code><a title="norm_outline.order_vectors" href="#norm_outline.order_vectors">order_vectors</a></code></li>
<li><code><a title="norm_outline.scale_magnitude" href="#norm_outline.scale_magnitude">scale_magnitude</a></code></li>
<li><code><a title="norm_outline.scale_vectors" href="#norm_outline.scale_vectors">scale_vectors</a></code></li>
<li><code><a title="norm_outline.sqrdiff" href="#norm_outline.sqrdiff">sqrdiff</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>